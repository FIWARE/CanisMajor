{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"CanisMajor - FIWARE Blockchain Adaptor CanisMajor is a blockchain adaptor that supports various DLT (Ethereum Client,IOTA, FABRIC chaincode (soon)), the adaptor aims to submit the data to DLT and works with NGSI-LD and NGSI-V2 as well. The adaptor is not be recommended to work for public-permissionless blockchains (specially tokens, cryptocurrencies). CanisMajor Adaptor recommend using AEI contract Model for the Ethereum Clients. AEI (Asset,Event, Identity) Smart Contract is written in Solidity using ERC721 standard (NFT).","title":"Home"},{"location":"index.html#canismajor-fiware-blockchain-adaptor","text":"CanisMajor is a blockchain adaptor that supports various DLT (Ethereum Client,IOTA, FABRIC chaincode (soon)), the adaptor aims to submit the data to DLT and works with NGSI-LD and NGSI-V2 as well. The adaptor is not be recommended to work for public-permissionless blockchains (specially tokens, cryptocurrencies). CanisMajor Adaptor recommend using AEI contract Model for the Ethereum Clients. AEI (Asset,Event, Identity) Smart Contract is written in Solidity using ERC721 standard (NFT).","title":"CanisMajor - FIWARE Blockchain Adaptor"},{"location":"apis.html","text":"APIs Meta Get the status curl --location --request GET 'http://localhost:4000/version' Response: { \"name\": \"canismajor\", \"version\": \"0.0.1\" } Generate Header TOKEN API to generate token using wallet keys Create a TOKEN curl --location --request POST 'http://localhost:4000/token' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"public_key\": \"HEQLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWOR99D\", \"private_key\": \"HEQLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWOR99D:PUEOTSEITFEVEWCWBTSIZM9NKRGJEIMXTULBACGFRQK9IMGICLBKW9TTEVSDQMGWKBXPVCBMMCXWMNPDX\" }' Response: { \"dlt-token\": \"7159c52fa533c84e5e62bba0cf9cb51147533194f5011310e007185977e92e9adc0e95755fea5792fd901252e8ce7977f11aa80088c94a06457f79e942dc22c769a7b7a458814ce71b597d5abf0ecd89a336d1162fd5f95c5ee6fd136d63391c347e5531034274c852f0a82789922e365a6bc54e0152cf274811327a67e3484151a2cef514671e35a2acd62f8341fa92d66342a6ef07a263281b17760b4ddcfbad1ca133ca7115fa451be9f5c35bd2c275b2bb4a5676634264d1a5c67b31a11a93a1871438ddb66f745afd88881255d0a3be16af3050c440f073e7025a931843b3d129921733bd50a607466c70f5f10d704bf6b39a0269691d40fd34bac25dd86715606eaeef84a04920370e9ce5e9b3dbebcb9805545e7e33ed62b3b4e27929f06f497793ce1a33b0c23ac2496c1564876f816cedd48174ea4a14797182bc3ade4479a5cae406de\" } TOKEN Info: { curl --location --request POST 'http://localhost:4000/token-info' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"dlt-token\": \"6f54f40abf32bb534407a49ac4b4973a417d0fadfa5a7c01fb070f226bc61c92d955a41750eb6ae7fcbf0e5be6dc151cf440af7c95d977715e50438d5a864aee739886df47937ac1012f4073a532e7a0aa27e42221c4926e4793fe6c715c086f3a6c78550f2508e1539681539f832e1b407af42b1a18b41c463e210078e2573d4bc7fb900f5b3707bcadd91a8d438efed83535d6\" }' Response: { { \"public_key\": \"0x042D550bbfFAbbEA8A672DB56f14F2Cee7BC59E5\", \"private_key\": \"0x6437760cd4f29dee72e4c026769ee8ea37a5c8d82930af071855495d0061dc8f\" } Config APIs when you are using and configuring your own contract use config api else it is recommended use AEI Standard Contract Method Get All the configs curl --location --request GET 'http://localhost:4000/config' Get the config by ID curl --location --request GET 'http://localhost:4000/config/16' Delete a config by ID curl --location --request DELETE 'http://localhost:4000/config/17' Create a config curl --location --request POST 'http://localhost:4000/config' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"contextType\": \"AgriProductType\", \"contextMapping\": { \"set\": [\"id\"] }, \"metadata\": { \"abi\": [ { \"constant\": false, \"inputs\": [ { \"name\": \"x\", \"type\": \"string\" } ], \"name\": \"set\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" } ], \"contractAddress\": \"0x089b05e9307e56c9dCbF6bd681c405b097bDa586\" } }' Response { \"id\": 1, \"contextType\": \"AgriProductType\", \"contextMapping\": { \"set\": [ \"id\" ] }, \"metadata\": { \"abi\": [ { \"constant\": false, \"inputs\": [ { \"name\": \"x\", \"type\": \"string\" } ], \"name\": \"set\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" } ], \"contractAddress\": \"0x089b05e9307e56c9dCbF6bd681c405b097bDa586\" }, \"updatedAt\": \"2021-06-07T13:33:57.750Z\", \"createdAt\": \"2021-06-07T13:33:57.750Z\" } Updating a config curl --location --request PUT 'http://localhost:4000/config/17' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"contextType\": \"AgriProductType\", \"contextMapping\": { \"set\": [\"price\"] }, \"metadata\": { \"abi\": [ { \"name\": \"set\", \"type\": \"function\", \"inputs\": [ { \"name\": \"x\", \"type\": \"uint256\" } ], \"outputs\": [], \"payable\": false, \"constant\": false, \"stateMutability\": \"nonpayable\" } ], \"contractAddress\": \"0x80734df3B3ac1A9381472158df979fd6328ea47D\" } }' Query Get All Entities curl --location --request GET 'http://localhost:4000/entity' Get Entity by Id curl --location --request GET 'http://localhost:4000/entity/74' Delete an Entity curl --location --request DELETE 'http://localhost:4000/entity/3' Get entity hash from the Smart Contarct (work's for ethereum client when using AEI contract) curl --location --request GET 'http://localhost:4000/entity/85/dlt' Get entity by query curl --location --request GET 'http://localhost:4000/entity?entityId=urn:ngsi-ld:Building:store021' Helpers Get Data from IPFS curl --location --request GET 'http://localhost:4000/ipfs/zdpuAkwkFon16cicgPHZMwziAqKfGDaQSj1VPsyZLCbmXFKgD' Get Data from IOTAMaM curl --location --request GET 'http://localhost:4000/iotaMaM/MWJTKMJHQTXLMEDHNV9TAJDAYCTPLGURKCTKYUQMY9CMKUNYX99DCXGQVOVSCHQEAAZGMXDDXA9POSKXJ' Get Data from IOTA as Tx curl --location --request GET 'http://localhost:4000/iotaTx/VFEWUIWNLAOGYWLLPNUYBV9CGFJWDSVNBJGLOZJOCWYUOIVWXWGGGDP9GTP9TMLIPBFVUVL9TYJUGB999' Verify Merkle Root Against given Payload (Result true or false) curl --location --request POST 'http://localhost:4000/merkle/bfc871626e72c2550bc2c3b4f70b7c42f2260f3f4a1dc9ebc731785da47a30a5/address' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"id\": \"urn:ngsi-ld:Building:store343\", \"type\": \"AgriProductType\", \"category\": { \"type\": \"Property\", \"value\": [\"commercial\"] }, \"address\": { \"type\": \"Property\", \"value\": { \"streetAddress\": \"Bornholmer Stra\u00dfe 65\", \"addressRegion\": \"Berlin\", \"addressLocality\": \"Prenzlauer Berg\", \"postalCode\": \"10439\" }, \"verified\": { \"type\": \"Property\", \"value\": true } }, \"@context\": [ \"https://fiware.github.io/data-models/context.jsonld\", \"https://uri.etsi.org/ngsi-ld/v1/ngsi-ld-core-context.jsonld\" ] }' Try out the postman collection here","title":"APIs"},{"location":"apis.html#apis","text":"","title":"APIs"},{"location":"apis.html#meta","text":"Get the status curl --location --request GET 'http://localhost:4000/version' Response: { \"name\": \"canismajor\", \"version\": \"0.0.1\" }","title":"Meta"},{"location":"apis.html#generate-header-token","text":"API to generate token using wallet keys Create a TOKEN curl --location --request POST 'http://localhost:4000/token' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"public_key\": \"HEQLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWOR99D\", \"private_key\": \"HEQLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWOR99D:PUEOTSEITFEVEWCWBTSIZM9NKRGJEIMXTULBACGFRQK9IMGICLBKW9TTEVSDQMGWKBXPVCBMMCXWMNPDX\" }' Response: { \"dlt-token\": \"7159c52fa533c84e5e62bba0cf9cb51147533194f5011310e007185977e92e9adc0e95755fea5792fd901252e8ce7977f11aa80088c94a06457f79e942dc22c769a7b7a458814ce71b597d5abf0ecd89a336d1162fd5f95c5ee6fd136d63391c347e5531034274c852f0a82789922e365a6bc54e0152cf274811327a67e3484151a2cef514671e35a2acd62f8341fa92d66342a6ef07a263281b17760b4ddcfbad1ca133ca7115fa451be9f5c35bd2c275b2bb4a5676634264d1a5c67b31a11a93a1871438ddb66f745afd88881255d0a3be16af3050c440f073e7025a931843b3d129921733bd50a607466c70f5f10d704bf6b39a0269691d40fd34bac25dd86715606eaeef84a04920370e9ce5e9b3dbebcb9805545e7e33ed62b3b4e27929f06f497793ce1a33b0c23ac2496c1564876f816cedd48174ea4a14797182bc3ade4479a5cae406de\" } TOKEN Info: { curl --location --request POST 'http://localhost:4000/token-info' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"dlt-token\": \"6f54f40abf32bb534407a49ac4b4973a417d0fadfa5a7c01fb070f226bc61c92d955a41750eb6ae7fcbf0e5be6dc151cf440af7c95d977715e50438d5a864aee739886df47937ac1012f4073a532e7a0aa27e42221c4926e4793fe6c715c086f3a6c78550f2508e1539681539f832e1b407af42b1a18b41c463e210078e2573d4bc7fb900f5b3707bcadd91a8d438efed83535d6\" }' Response: { { \"public_key\": \"0x042D550bbfFAbbEA8A672DB56f14F2Cee7BC59E5\", \"private_key\": \"0x6437760cd4f29dee72e4c026769ee8ea37a5c8d82930af071855495d0061dc8f\" }","title":"Generate Header TOKEN"},{"location":"apis.html#config","text":"APIs when you are using and configuring your own contract use config api else it is recommended use AEI Standard Contract Method Get All the configs curl --location --request GET 'http://localhost:4000/config' Get the config by ID curl --location --request GET 'http://localhost:4000/config/16' Delete a config by ID curl --location --request DELETE 'http://localhost:4000/config/17' Create a config curl --location --request POST 'http://localhost:4000/config' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"contextType\": \"AgriProductType\", \"contextMapping\": { \"set\": [\"id\"] }, \"metadata\": { \"abi\": [ { \"constant\": false, \"inputs\": [ { \"name\": \"x\", \"type\": \"string\" } ], \"name\": \"set\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" } ], \"contractAddress\": \"0x089b05e9307e56c9dCbF6bd681c405b097bDa586\" } }' Response { \"id\": 1, \"contextType\": \"AgriProductType\", \"contextMapping\": { \"set\": [ \"id\" ] }, \"metadata\": { \"abi\": [ { \"constant\": false, \"inputs\": [ { \"name\": \"x\", \"type\": \"string\" } ], \"name\": \"set\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" } ], \"contractAddress\": \"0x089b05e9307e56c9dCbF6bd681c405b097bDa586\" }, \"updatedAt\": \"2021-06-07T13:33:57.750Z\", \"createdAt\": \"2021-06-07T13:33:57.750Z\" } Updating a config curl --location --request PUT 'http://localhost:4000/config/17' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"contextType\": \"AgriProductType\", \"contextMapping\": { \"set\": [\"price\"] }, \"metadata\": { \"abi\": [ { \"name\": \"set\", \"type\": \"function\", \"inputs\": [ { \"name\": \"x\", \"type\": \"uint256\" } ], \"outputs\": [], \"payable\": false, \"constant\": false, \"stateMutability\": \"nonpayable\" } ], \"contractAddress\": \"0x80734df3B3ac1A9381472158df979fd6328ea47D\" } }'","title":"Config"},{"location":"apis.html#query","text":"Get All Entities curl --location --request GET 'http://localhost:4000/entity' Get Entity by Id curl --location --request GET 'http://localhost:4000/entity/74' Delete an Entity curl --location --request DELETE 'http://localhost:4000/entity/3' Get entity hash from the Smart Contarct (work's for ethereum client when using AEI contract) curl --location --request GET 'http://localhost:4000/entity/85/dlt' Get entity by query curl --location --request GET 'http://localhost:4000/entity?entityId=urn:ngsi-ld:Building:store021'","title":"Query"},{"location":"apis.html#helpers","text":"Get Data from IPFS curl --location --request GET 'http://localhost:4000/ipfs/zdpuAkwkFon16cicgPHZMwziAqKfGDaQSj1VPsyZLCbmXFKgD' Get Data from IOTAMaM curl --location --request GET 'http://localhost:4000/iotaMaM/MWJTKMJHQTXLMEDHNV9TAJDAYCTPLGURKCTKYUQMY9CMKUNYX99DCXGQVOVSCHQEAAZGMXDDXA9POSKXJ' Get Data from IOTA as Tx curl --location --request GET 'http://localhost:4000/iotaTx/VFEWUIWNLAOGYWLLPNUYBV9CGFJWDSVNBJGLOZJOCWYUOIVWXWGGGDP9GTP9TMLIPBFVUVL9TYJUGB999' Verify Merkle Root Against given Payload (Result true or false) curl --location --request POST 'http://localhost:4000/merkle/bfc871626e72c2550bc2c3b4f70b7c42f2260f3f4a1dc9ebc731785da47a30a5/address' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"id\": \"urn:ngsi-ld:Building:store343\", \"type\": \"AgriProductType\", \"category\": { \"type\": \"Property\", \"value\": [\"commercial\"] }, \"address\": { \"type\": \"Property\", \"value\": { \"streetAddress\": \"Bornholmer Stra\u00dfe 65\", \"addressRegion\": \"Berlin\", \"addressLocality\": \"Prenzlauer Berg\", \"postalCode\": \"10439\" }, \"verified\": { \"type\": \"Property\", \"value\": true } }, \"@context\": [ \"https://fiware.github.io/data-models/context.jsonld\", \"https://uri.etsi.org/ngsi-ld/v1/ngsi-ld-core-context.jsonld\" ] }' Try out the postman collection here","title":"Helpers"},{"location":"architecture.html","text":"Architecture Canis Major in powered by FIWARE Architecture Canis major uses FIWARE Pep-Proxy (fork version) link which allow to config \"canismajor endpoint\" process.env.CANIS_MAJOR_URL = http://localhost:4000 (canis major endpoint) Flow Diagram The way Canis Major work's in 'Powered By FIWARE' architecture as follows: Request from the user is consist of the Payload, Header with token and DLT_ID (base64 of public key and private key of the blockchain). Wilma PEP Proxy validate the token and check with the KeyRock IDM and validate the user, permission (Authentication and Autherisation). Once the user is validate Wilma forward the request to the Context Broker and persist it. Once the Payload stored in Context Broker Wilma notify to Canis Major with the configuration such as what attribute of the payload should be store, Blockchain Identity of the user. Futher Canis Major persist the data in blockchain using AEI contract (will be explained futher in this chapter). Canis Major Design: Canis major is designed to submit the transaction in diffrent kind of DLT current it support these blockchain Supported DLT Clients [x] Ethereum [x] IOTA [ ] FABRIC Chaincode and is not recommended to use in public-permissionless or crypotcurrencies. For the Etherum Clients such as geth, quorum, besu etc it is recommended to use AEI contract (plese check the contract section in this documentation), though you can also use your own contract and configure it using canismajor rest api. Canis Major also support varsion storage type store the payload Storage Type [x] IPFS [x] IOTA MaM [x] Merkle Tree IPFS You can use IPFS, a distributed system for storing and accessing files and data, in Canis Major Adaptor. To learn about IPFS please follow here IOTAMaM (Masked Authenticated Messaging) Canis Major Also Supporta IOTA MaM. The IOTA Tangle allows you to attach zero-value transactions to it, but these transactions are not signed or checked by nodes to verify their authenticity. With MAM, all messages are signed by the owner of a seed. To learn about IOTA MaM please follow link MerkleTree Merkle trees are data structures devised to authenticate, with a unique signature, a set of messages, by at the same time making an intended verifier able to verify authenticity of a single message without the disclosure of the other messages. To learn about Merkle Tree please follow link In a canis major merkle is use as mentioned in below AEI Contract Model AEI (Asset, Event and Identity) Smart Contract is written in Solidity using ERC721 standard (NFT) and can be use with Ethereum Clients. It is compatible with FIWARE-Canis Major Adaptor to store the data in blockchain. ERC 721 Contract is follow OpenZepplin standards, security audits are trusted by leading organizations building decentralized systems. ERC 721 ERC 721 A standard interface for non-fungible tokens, also known as deeds. The following standard allows for the implementation of a standard API for NFTs within smart contracts. This standard provides basic functionality to track and transfer NFTs. We considered use cases of NFTs being owned and transacted by individuals as well as consignment to third party brokers/wallets/auctioneers (\u201coperators\u201d). NFTs can represent ownership over digital or physical assets. We considered a diverse universe of assets, and we know you will dream up many more: Physical property \u2014 houses, unique artwork Virtual collectables \u2014 unique pictures of kittens, collectable cards \u201cNegative value\u201d assets \u2014 loans, burdens and other responsibilities In general, all houses are distinct and no two kittens are alike. NFTs are distinguishable and you must track the ownership of each one separately. to know more follow here: ERC 721 OpenZepplin ERC721 AEI Architecture AEI Contract Design Entity/Asset with a unique identity will be a new asset (1:1 mapping of asset to an identity). Event or Metadata of the asset/entity has a 1:n mapping. An Asset can have a 1:n relationship with any other asset. Example Supported Methods - createAsset(bytes32 uuid, string memory _newHash) - getAsset(bytes32 uuid) - updateAsset(bytes32 uuid, string memory _newHash) - removeAsset (bytes32 uuid) - isValidAsset(bytes32 uuid, bytes32[] memory _proof, bytes32 _leaf) - isValidAssetEthMessage(bytes32 uuid, bytes32 _messageHash, bytes memory _signature) - addRelation(bytes32 uuid, bytes32 reluuid) - getRelations(bytes32 uuid) - removeRelation(bytes32 uuid, uint index) - isValidRelation(bytes32 uuid, uint index, bytes32[] memory _proof, bytes32 _leaf) - addMetadata(bytes32 uuid, string memory _metadatahash) - getMetadatas(bytes32 uuid) public view returns (string[] memory) - removeMetadata(bytes32 uuid, uint index) - isValidMetadata(bytes32 uuid, uint index, bytes32[] memory _proof, bytes32 _leaf) Apart from that ERC721, Ownable, MerkleProof, ECDSA methods are supported. Dependencies This project uses: - truffle - NodeJS - Ganache-CLI (testrpc) - OpenZeppelin Canis Major with AEI Contract: Use of Canis Major CanisMajor is a blockchain adaptor that supports various DLT. Canis Major Design The way Canis Major work's in 'Powered By FIWARE' architecture as follows: Request from the user is consist of the Payload, Header with token and dlt-token (can be generate using canis major token api, please follow the api docs). Wilma PEP Proxy validate the token and check with the KeyRock IDM and validate the user, permission (Authentication and Autherisation). Once the user is validate Wilma forward the request to the Context Broker and persist it. Once the Payload stored in Context Broker Wilma notify to Canis Major with the configuration such as what attribute of the payload should be store, Blockchain Identity of the user. Futher Canis Major persist the data in blockchain using AEI contract (will be explained futher in this chapter). Github Souce Documentation Usages Creation of an Entity (Animal, Farm etc) Creation of an entity goes as follow: Actor create an request with a payload to PEP Proxy. the request is consist of the payload and in header TOKEN (generate from the keyrock IDM) and the DLT_KEYS (which is a base64 for public and private key of the wallet). Wilma autherize the request of the user by validating it from the keyrock IDM. On Success wilma submit the request to the Context Broker and the entity will be store. On Successfully entity creation wilma notify the CanisMajor Adaptor to persist the entity in blockchain (where the smart contract is already configured). Willma notify the CanisMajor with payload, dlt_keys in header and it also support option ctx_map (which allow user to mention what particular keys from the payload should be persist in the smart contract). Canis Major further validate the DLT_KEY (identity), create a signed transaction and submit it to the blockchain. Here we are using AEI_Contract and the createAsset method of the contract is called. On successful transacation creation the tx_reciept of the transaction will be available in canis major, which can be queried any time. Adding Metadata (eventy) on an Entity (Animal, Farm etc) Adding Metadata on an entity goes as follow: Actor create an request with a payload to PEP Proxy. the request is consist of the payload and in header TOKEN (generate from the keyrock IDM) and the DLT_KEYS (which is a base64 for public and private key of the wallet). Wilma autherize the request of the user by validating it from the keyrock IDM. On Success wilma submit the request to the Context Broker with the meta information and entity_id. On Successfully entity creation wilma notify the CanisMajor Adaptor to persist the entity in blockchain (where the smart contract is already configured). Willma notify the CanisMajor with payload, dlt_keys in header and it also support option ctx_map (which allow user to mention what particular keys from the payload should be persist in the smart contract). Canis Major further validate the DLT_KEY (identity), create a signed transaction and submit it to the blockchain. here the request is for adding the metadata, canis major will call AddMetadata method of the AEI Contract. On successful transacation creation the tx_reciept of the transaction will be available in canis major, which can be queried any time. Qyery Quering the data on blockchain goes as follow: Actor send a request to canis major with the Entity_ID. Canis major check the transaction details from the local storage and fetch the reciept. Canis Major futher call the AEI contarct, getAsset method and the fetch the stored hash. Hash will be returned back to the hash. **Note: the returned Hash could be a IPFS Hash, IOTAMaM hash or MerkleRoot, depend on the configuration of the CanisMajor and data from the has can be fetched or validated from the canismajor query apis (for more checkout the canismajor api specification)\"","title":"Architecture"},{"location":"architecture.html#architecture","text":"","title":"Architecture"},{"location":"architecture.html#canis-major-in-powered-by-fiware-architecture","text":"Canis major uses FIWARE Pep-Proxy (fork version) link which allow to config \"canismajor endpoint\" process.env.CANIS_MAJOR_URL = http://localhost:4000 (canis major endpoint)","title":"Canis Major in powered by FIWARE Architecture"},{"location":"architecture.html#flow-diagram","text":"The way Canis Major work's in 'Powered By FIWARE' architecture as follows: Request from the user is consist of the Payload, Header with token and DLT_ID (base64 of public key and private key of the blockchain). Wilma PEP Proxy validate the token and check with the KeyRock IDM and validate the user, permission (Authentication and Autherisation). Once the user is validate Wilma forward the request to the Context Broker and persist it. Once the Payload stored in Context Broker Wilma notify to Canis Major with the configuration such as what attribute of the payload should be store, Blockchain Identity of the user. Futher Canis Major persist the data in blockchain using AEI contract (will be explained futher in this chapter).","title":"Flow Diagram"},{"location":"architecture.html#canis-major-design","text":"Canis major is designed to submit the transaction in diffrent kind of DLT current it support these blockchain","title":"Canis Major Design:"},{"location":"architecture.html#supported-dlt-clients","text":"[x] Ethereum [x] IOTA [ ] FABRIC Chaincode and is not recommended to use in public-permissionless or crypotcurrencies. For the Etherum Clients such as geth, quorum, besu etc it is recommended to use AEI contract (plese check the contract section in this documentation), though you can also use your own contract and configure it using canismajor rest api. Canis Major also support varsion storage type store the payload","title":"Supported DLT Clients"},{"location":"architecture.html#storage-type","text":"[x] IPFS [x] IOTA MaM [x] Merkle Tree","title":"Storage Type"},{"location":"architecture.html#ipfs","text":"You can use IPFS, a distributed system for storing and accessing files and data, in Canis Major Adaptor. To learn about IPFS please follow here","title":"IPFS"},{"location":"architecture.html#iotamam-masked-authenticated-messaging","text":"Canis Major Also Supporta IOTA MaM. The IOTA Tangle allows you to attach zero-value transactions to it, but these transactions are not signed or checked by nodes to verify their authenticity. With MAM, all messages are signed by the owner of a seed. To learn about IOTA MaM please follow link","title":"IOTAMaM (Masked Authenticated Messaging)"},{"location":"architecture.html#merkletree","text":"Merkle trees are data structures devised to authenticate, with a unique signature, a set of messages, by at the same time making an intended verifier able to verify authenticity of a single message without the disclosure of the other messages. To learn about Merkle Tree please follow link In a canis major merkle is use as mentioned in below","title":"MerkleTree"},{"location":"architecture.html#aei-contract-model","text":"AEI (Asset, Event and Identity) Smart Contract is written in Solidity using ERC721 standard (NFT) and can be use with Ethereum Clients. It is compatible with FIWARE-Canis Major Adaptor to store the data in blockchain. ERC 721 Contract is follow OpenZepplin standards, security audits are trusted by leading organizations building decentralized systems.","title":"AEI Contract Model"},{"location":"architecture.html#erc-721","text":"ERC 721 A standard interface for non-fungible tokens, also known as deeds. The following standard allows for the implementation of a standard API for NFTs within smart contracts. This standard provides basic functionality to track and transfer NFTs. We considered use cases of NFTs being owned and transacted by individuals as well as consignment to third party brokers/wallets/auctioneers (\u201coperators\u201d). NFTs can represent ownership over digital or physical assets. We considered a diverse universe of assets, and we know you will dream up many more: Physical property \u2014 houses, unique artwork Virtual collectables \u2014 unique pictures of kittens, collectable cards \u201cNegative value\u201d assets \u2014 loans, burdens and other responsibilities In general, all houses are distinct and no two kittens are alike. NFTs are distinguishable and you must track the ownership of each one separately. to know more follow here: ERC 721 OpenZepplin ERC721","title":"ERC 721"},{"location":"architecture.html#aei-architecture","text":"AEI Contract Design Entity/Asset with a unique identity will be a new asset (1:1 mapping of asset to an identity). Event or Metadata of the asset/entity has a 1:n mapping. An Asset can have a 1:n relationship with any other asset.","title":"AEI Architecture"},{"location":"architecture.html#example","text":"","title":"Example"},{"location":"architecture.html#supported-methods","text":"- createAsset(bytes32 uuid, string memory _newHash) - getAsset(bytes32 uuid) - updateAsset(bytes32 uuid, string memory _newHash) - removeAsset (bytes32 uuid) - isValidAsset(bytes32 uuid, bytes32[] memory _proof, bytes32 _leaf) - isValidAssetEthMessage(bytes32 uuid, bytes32 _messageHash, bytes memory _signature) - addRelation(bytes32 uuid, bytes32 reluuid) - getRelations(bytes32 uuid) - removeRelation(bytes32 uuid, uint index) - isValidRelation(bytes32 uuid, uint index, bytes32[] memory _proof, bytes32 _leaf) - addMetadata(bytes32 uuid, string memory _metadatahash) - getMetadatas(bytes32 uuid) public view returns (string[] memory) - removeMetadata(bytes32 uuid, uint index) - isValidMetadata(bytes32 uuid, uint index, bytes32[] memory _proof, bytes32 _leaf) Apart from that ERC721, Ownable, MerkleProof, ECDSA methods are supported.","title":"Supported Methods"},{"location":"architecture.html#dependencies","text":"This project uses: - truffle - NodeJS - Ganache-CLI (testrpc) - OpenZeppelin","title":"Dependencies"},{"location":"architecture.html#canis-major-with-aei-contract","text":"","title":"Canis Major with AEI Contract:"},{"location":"architecture.html#use-of-canis-major","text":"CanisMajor is a blockchain adaptor that supports various DLT.","title":"Use of Canis Major"},{"location":"architecture.html#canis-major-design_1","text":"The way Canis Major work's in 'Powered By FIWARE' architecture as follows: Request from the user is consist of the Payload, Header with token and dlt-token (can be generate using canis major token api, please follow the api docs). Wilma PEP Proxy validate the token and check with the KeyRock IDM and validate the user, permission (Authentication and Autherisation). Once the user is validate Wilma forward the request to the Context Broker and persist it. Once the Payload stored in Context Broker Wilma notify to Canis Major with the configuration such as what attribute of the payload should be store, Blockchain Identity of the user. Futher Canis Major persist the data in blockchain using AEI contract (will be explained futher in this chapter). Github Souce Documentation","title":"Canis Major Design"},{"location":"architecture.html#usages","text":"","title":"Usages"},{"location":"architecture.html#creation-of-an-entity-animal-farm-etc","text":"Creation of an entity goes as follow: Actor create an request with a payload to PEP Proxy. the request is consist of the payload and in header TOKEN (generate from the keyrock IDM) and the DLT_KEYS (which is a base64 for public and private key of the wallet). Wilma autherize the request of the user by validating it from the keyrock IDM. On Success wilma submit the request to the Context Broker and the entity will be store. On Successfully entity creation wilma notify the CanisMajor Adaptor to persist the entity in blockchain (where the smart contract is already configured). Willma notify the CanisMajor with payload, dlt_keys in header and it also support option ctx_map (which allow user to mention what particular keys from the payload should be persist in the smart contract). Canis Major further validate the DLT_KEY (identity), create a signed transaction and submit it to the blockchain. Here we are using AEI_Contract and the createAsset method of the contract is called. On successful transacation creation the tx_reciept of the transaction will be available in canis major, which can be queried any time.","title":"Creation of an Entity (Animal, Farm etc)"},{"location":"architecture.html#adding-metadata-eventy-on-an-entity-animal-farm-etc","text":"Adding Metadata on an entity goes as follow: Actor create an request with a payload to PEP Proxy. the request is consist of the payload and in header TOKEN (generate from the keyrock IDM) and the DLT_KEYS (which is a base64 for public and private key of the wallet). Wilma autherize the request of the user by validating it from the keyrock IDM. On Success wilma submit the request to the Context Broker with the meta information and entity_id. On Successfully entity creation wilma notify the CanisMajor Adaptor to persist the entity in blockchain (where the smart contract is already configured). Willma notify the CanisMajor with payload, dlt_keys in header and it also support option ctx_map (which allow user to mention what particular keys from the payload should be persist in the smart contract). Canis Major further validate the DLT_KEY (identity), create a signed transaction and submit it to the blockchain. here the request is for adding the metadata, canis major will call AddMetadata method of the AEI Contract. On successful transacation creation the tx_reciept of the transaction will be available in canis major, which can be queried any time.","title":"Adding Metadata (eventy) on an Entity (Animal, Farm etc)"},{"location":"architecture.html#qyery","text":"Quering the data on blockchain goes as follow: Actor send a request to canis major with the Entity_ID. Canis major check the transaction details from the local storage and fetch the reciept. Canis Major futher call the AEI contarct, getAsset method and the fetch the stored hash. Hash will be returned back to the hash. **Note: the returned Hash could be a IPFS Hash, IOTAMaM hash or MerkleRoot, depend on the configuration of the CanisMajor and data from the has can be fetched or validated from the canismajor query apis (for more checkout the canismajor api specification)\"","title":"Qyery"},{"location":"installation.html","text":"Installation Guide This section describes installing Canis Major Blockchain Adaptor: Requirments In order to execute Canis Major, it is needed to have previously installed the following software: - NodeJS 12 - ORM Database (SQL, Postgres) # Installation The following steps need to be performed to get Canis Major up and running: Download the software, using GitHub. git clone https://github.com/fiware/canismajor Install all required libraries using npm. cd canismajor npm install Database Init/Migration DB_USERNAME=${DB_USERNAME} \\ DB_PASSWORD=${DB_PASSWORD} \\ DB_NAME=${DB_NAME} \\ DB_HOST=${DB_HOST} \\ DB_PORT=${DB_PORT} \\ npm run create && npm run migrate Configure the installation - DB_NAME - DB_HOST - DB_PORT - DB_DILECT - DB_USERNAME - DB_PASSWORD - CM_PORT - TRANSCTION_TIMEOUT - DLT_TYPE // eth or iota - IOTA_ENDPOINT // iota config // eth config - RPC_ENDPOINT - DEFAULT_GAS - DEFAULT_GAS_PRICE - AEI_CONTRACT_MODE - CONTRACT_ADDRESS // storage config - STORAGE_TYPE // iota, ipfs or merkletree - IPFS_HOST - IPFS_PORT - IPFS_PROTOCOL - IPFS_AUTH_CODE - IOTAMAM_HOST - IOTAMAM_MODE ENV Variable Description Example DB_NAME Name of the Database cm DB_HOST Database HOST name localhost DB_PORT Database PORT number 3306 DB_DILECT Database Dilect (sequlize ORM) can be mysql, postgres mysql DB_USERNAME Database User Name root DB_PASSWORD Database Password root TRANSCTION_TIMEOUT Transaction timeout 1000 DLT_TYPE Ledger or Blockchain Type (Can be eth or iota) eth IOTA_ENDPOINT (optional) IOTA Endpoint (required) when the DLT_TYPE=iota 'https://nodes.devnet.iota.org:443' RPC_ENDPOINT Endpoint of the ethereum client 'http://127.0.0.1:8545' DEFAULT_GAS Default GAS usage of the Eth Smart Contract 300000 AEI_CONTRACT_MODE AEI contract enabled or not true CONTRACT_ADDRESS Contract Address of the deployed smart contract 0xcd125237903865f39caf6443209c89bA70a4A385 Storage Configuration ipfs ENV Variable Description Example STORAGE_TYPE Storage type to store the payload (can be ipfs, iota or merkletree) ipfs IPFS_HOST IPFS host name ipfs.infura.io IPFS_PORT IPFS port number 5001 IPFS_PROTOCOL IPFS protocol https IPFS_AUTH_CODE (optional) Bearer Auth code \" \" IOTAMaM ENV Variable Description Example STORAGE_TYPE Storage type to store the payload (can be ipfs, iota or merkletree) iota IOTAMAM_HOST IOTAMaM Host Name https://nodes.devnet.iota.org IOTAMAM_MODE IOTAMaM mode (can be public or private) public Merkle Tree ENV Variable Description Example STORAGE_TYPE Storage type to store the payload (can be ipfs, iota or merkletree) merkletree Configuration diagram there configuration can be also mentioned in src/configuration/config.js Running the CanisMajor npm start or in development mode: npm run dev","title":"Installation"},{"location":"installation.html#installation-guide","text":"This section describes installing Canis Major Blockchain Adaptor:","title":"Installation Guide"},{"location":"installation.html#requirments","text":"In order to execute Canis Major, it is needed to have previously installed the following software: - NodeJS 12 - ORM Database (SQL, Postgres) # Installation The following steps need to be performed to get Canis Major up and running: Download the software, using GitHub. git clone https://github.com/fiware/canismajor Install all required libraries using npm. cd canismajor npm install Database Init/Migration DB_USERNAME=${DB_USERNAME} \\ DB_PASSWORD=${DB_PASSWORD} \\ DB_NAME=${DB_NAME} \\ DB_HOST=${DB_HOST} \\ DB_PORT=${DB_PORT} \\ npm run create && npm run migrate Configure the installation - DB_NAME - DB_HOST - DB_PORT - DB_DILECT - DB_USERNAME - DB_PASSWORD - CM_PORT - TRANSCTION_TIMEOUT - DLT_TYPE // eth or iota - IOTA_ENDPOINT // iota config // eth config - RPC_ENDPOINT - DEFAULT_GAS - DEFAULT_GAS_PRICE - AEI_CONTRACT_MODE - CONTRACT_ADDRESS // storage config - STORAGE_TYPE // iota, ipfs or merkletree - IPFS_HOST - IPFS_PORT - IPFS_PROTOCOL - IPFS_AUTH_CODE - IOTAMAM_HOST - IOTAMAM_MODE ENV Variable Description Example DB_NAME Name of the Database cm DB_HOST Database HOST name localhost DB_PORT Database PORT number 3306 DB_DILECT Database Dilect (sequlize ORM) can be mysql, postgres mysql DB_USERNAME Database User Name root DB_PASSWORD Database Password root TRANSCTION_TIMEOUT Transaction timeout 1000 DLT_TYPE Ledger or Blockchain Type (Can be eth or iota) eth IOTA_ENDPOINT (optional) IOTA Endpoint (required) when the DLT_TYPE=iota 'https://nodes.devnet.iota.org:443' RPC_ENDPOINT Endpoint of the ethereum client 'http://127.0.0.1:8545' DEFAULT_GAS Default GAS usage of the Eth Smart Contract 300000 AEI_CONTRACT_MODE AEI contract enabled or not true CONTRACT_ADDRESS Contract Address of the deployed smart contract 0xcd125237903865f39caf6443209c89bA70a4A385 Storage Configuration ipfs ENV Variable Description Example STORAGE_TYPE Storage type to store the payload (can be ipfs, iota or merkletree) ipfs IPFS_HOST IPFS host name ipfs.infura.io IPFS_PORT IPFS port number 5001 IPFS_PROTOCOL IPFS protocol https IPFS_AUTH_CODE (optional) Bearer Auth code \" \" IOTAMaM ENV Variable Description Example STORAGE_TYPE Storage type to store the payload (can be ipfs, iota or merkletree) iota IOTAMAM_HOST IOTAMaM Host Name https://nodes.devnet.iota.org IOTAMAM_MODE IOTAMaM mode (can be public or private) public Merkle Tree ENV Variable Description Example STORAGE_TYPE Storage type to store the payload (can be ipfs, iota or merkletree) merkletree Configuration diagram there configuration can be also mentioned in src/configuration/config.js Running the CanisMajor npm start or in development mode: npm run dev","title":"Requirments"},{"location":"usage.html","text":"Usages Documentation is pending for the demo please follow the tutorial here","title":"Usage"},{"location":"usage.html#usages","text":"Documentation is pending for the demo please follow the tutorial here","title":"Usages"}]}